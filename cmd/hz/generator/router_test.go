package generator

import (
	"testing"
)

func TestRouterRegisterDuplicateDetection(t *testing.T) {
	// Test case 1: Different package aliases should not conflict
	testCases := []struct {
		name           string
		fileContent    string
		depPkgAlias    string
		shouldConflict bool
	}{
		{
			name: "Different package aliases should not conflict",
			fileContent: `// Code generated by hertz generator. DO NOT EDIT.

package main

import (
	"github.com/cloudwego/hertz/pkg/app/server"
	strategy "github.com/example/strategy"
	appstrategy "github.com/example/appstrategy"
)

// GeneratedRegister registers routers generated by IDL.
func GeneratedRegister(r *server.Hertz){
	//INSERT_POINT: DO NOT DELETE THIS LINE!
	strategy.Register(r)
}`,
			depPkgAlias:    "appstrategy",
			shouldConflict: false,
		},
		{
			name: "Same package alias should conflict",
			fileContent: `// Code generated by hertz generator. DO NOT EDIT.

package main

import (
	"github.com/cloudwego/hertz/pkg/app/server"
	strategy "github.com/example/strategy"
)

// GeneratedRegister registers routers generated by IDL.
func GeneratedRegister(r *server.Hertz){
	//INSERT_POINT: DO NOT DELETE THIS LINE!
	strategy.Register(r)
}`,
			depPkgAlias:    "strategy",
			shouldConflict: true,
		},
		{
			name: "Similar but different package aliases should not conflict",
			fileContent: `// Code generated by hertz generator. DO NOT EDIT.

package main

import (
	"github.com/cloudwego/hertz/pkg/app/server"
	user "github.com/example/user"
)

// GeneratedRegister registers routers generated by IDL.
func GeneratedRegister(r *server.Hertz){
	//INSERT_POINT: DO NOT DELETE THIS LINE!
	user.Register(r)
}`,
			depPkgAlias:    "username",
			shouldConflict: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Use the extracted function instead of duplicating logic
			conflict := hasRouterRegistration(tc.fileContent, tc.depPkgAlias)

			if conflict != tc.shouldConflict {
				t.Errorf("Expected conflict: %v, got: %v", tc.shouldConflict, conflict)
			}
		})
	}
}

func TestRegRouterRegisterRegex(t *testing.T) {
	testCases := []struct {
		input    string
		expected bool
	}{
		{"strategy.Register(r)", true},
		{"appstrategy.Register(r)", true},
		{"user.Register(r)", true},
		{"strategy.Register(r) ", true},            // with trailing space
		{" strategy.Register(r)", true},            // with leading space
		{"\tstrategy.Register(r)", true},           // with tab
		{"strategy.Register(r)\n", false},          // with newline
		{"strategy.Register(r) // comment", false}, // with comment
		{"appstrategy.Register(r)", true},
		{"strategy.Register(r)strategy.Register(r)", false}, // not exact match
		{"strategy.Register(r)other", false},                // not exact match
	}

	for _, tc := range testCases {
		t.Run(tc.input, func(t *testing.T) {
			result := regRouterRegister.MatchString(tc.input)
			if result != tc.expected {
				t.Errorf("Input: %q, Expected: %v, Got: %v", tc.input, tc.expected, result)
			}
		})
	}
}

func TestHasRouterRegistration(t *testing.T) {
	testCases := []struct {
		name           string
		fileContent    string
		depPkgAlias    string
		expectedResult bool
	}{
		{
			name: "Should detect existing registration",
			fileContent: `package main

func GeneratedRegister(r *server.Hertz) {
	strategy.Register(r)
}`,
			depPkgAlias:    "strategy",
			expectedResult: true,
		},
		{
			name: "Should not detect non-existing registration",
			fileContent: `package main

func GeneratedRegister(r *server.Hertz) {
	user.Register(r)
}`,
			depPkgAlias:    "strategy",
			expectedResult: false,
		},
		{
			name: "Should handle registration with whitespace",
			fileContent: `package main

func GeneratedRegister(r *server.Hertz) {
	 strategy.Register(r) 
}`,
			depPkgAlias:    "strategy",
			expectedResult: true,
		},
		{
			name: "Should handle registration with tabs",
			fileContent: `package main

func GeneratedRegister(r *server.Hertz) {
		strategy.Register(r)
}`,
			depPkgAlias:    "strategy",
			expectedResult: true,
		},
		{
			name: "Should not match partial registration",
			fileContent: `package main

func GeneratedRegister(r *server.Hertz) {
	strategy.Register(r) // comment
}`,
			depPkgAlias:    "strategy",
			expectedResult: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result := hasRouterRegistration(tc.fileContent, tc.depPkgAlias)
			if result != tc.expectedResult {
				t.Errorf("Expected: %v, Got: %v", tc.expectedResult, result)
			}
		})
	}
}
